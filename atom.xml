<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[杨叫兽的技术博客]]></title>
  <link href="http://nijino.cn/atom.xml" rel="self"/>
  <link href="http://nijino.cn/"/>
  <updated>2013-08-14T01:41:16+08:00</updated>
  <id>http://nijino.cn/</id>
  <author>
    <name><![CDATA[杨叫兽]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Xcode5中cellForRowAtIndexPath:方法]]></title>
    <link href="http://nijino.cn/blog/2013/08/12/new-cell-for-row/"/>
    <updated>2013-08-12T14:57:00+08:00</updated>
    <id>http://nijino.cn/blog/2013/08/12/new-cell-for-row</id>
    <content type="html"><![CDATA[<p>UITableView是绝大部分iOS开发中必不可少的类。它的优势在于自身会维持一个可复用的队列，对于提高系统运行的流畅性有着不可磨灭的作用。</p>

<p>可复用的队列一般要写在UITableView的cellForRowAtIndexPath:方法中，之前的写法一般是这样：</p>

<!-- more -->


<p></p>

<pre><code>static NSString *CellIdentifier = @"Cell";
UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier];
if (cell == nil){
    cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:CellIdentifier];
}

// Configure the cell

return cell;    
</code></pre>

<p>上面这段代码的原理是首先会定义一个静态单元格标识，之后看看可复用队列中是否存在带有这个标识的单元格，如果没有就要重新生成。</p>

<p>对于一些拥有一段iOS开发经验的开发者来说这段代码应该是再熟悉不过，因为好多应用都会用到UITableView。但是最近我在Xcode DP版本上发现这段代码有了变化，在Xcode5中新生成UITableView的cellForRowAtIndexPath:方法中的写法变成了以下这样：</p>

<pre><code>static NSString *CellIdentifier = @"Cell";
UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier forIndexPath:indexPath];

// Configure the cell...

return cell;
</code></pre>

<p>表面上看UITableView好像支持了一个新方法：dequeueReusableCellWithIdentifier:forIndexPath:,这个方法是怎么回事呢？赶紧来看看这个方法的说明：</p>

<p><img src="http://nijino.cn/images/xcode5-cellForRow.png" alt="image" /></p>

<p>从这个说明文档中可以知道这个方法也可以从复用队列中提取cell。如果cell没有在复用队列中，那就会调用cell的initWithStyle:reuseIdentifier:方法生成新的cell。至于之前在代码中指定cell的风格，现在已经可以在storyboard中指定了。</p>

<p>上面这个例子充分说明了苹果在简化代码方面作出的巨大努力。Objective－C本身语法就有些长，如果不深入研究一些简化代码的写法，那么一个项目的代码就会变的非常冗余。这也是程序员经常说的把代码写多容易，而把代码量减少并且不丧失功能才是有难度的。</p>

<p>另外我注意到这个方法是从iOS6.0版本开始支持的，可是在Xcode4.6.3中生成新的UITableViewController并不会默认生成新方法，只有Xcode5中才会生成，不知道这个方法在Xcode4.6.3中是否可以使用，需要通过实践来检验。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[KVC技巧二则]]></title>
    <link href="http://nijino.cn/blog/2013/07/02/using-kvc/"/>
    <updated>2013-07-02T14:31:00+08:00</updated>
    <id>http://nijino.cn/blog/2013/07/02/using-kvc</id>
    <content type="html"><![CDATA[<p>说两个与KVC相关的技巧。</p>

<p>1.KVC与字典</p>

<p>有时候我们需要取出嵌套字典中的某个键的值。例如某个嵌套字典：</p>

<p><code>   NSDictionary *dict = @{@"subDict":@{@"subKey":@"aStr"}};</code></p>

<!-- more -->


<p>需要取出<code>subKey</code>这个键的值。以前总是用<code>valueForKey</code>嵌套的语法来做，其实根本不用那么麻烦，直接利用<code>valueForKeyPath</code>方法就可以实现。代码如下：</p>

<pre><code>NSString *str = [dict valueForKeyPath:@"subDict.subKey"];
</code></pre>

<p>2.KVC实现高阶消息传递</p>

<p>有时候需要对数组中每个对象调用某一个方法后生成新的数组，我们可以利用KVC的高阶消息传递功能来实现。例如有下面这样一个数组：</p>

<p><code>   NSArray *originArr = @[@"octopress",@"nijino",@"saki"];</code></p>

<p>我想将这个数组中的每一个元素首字母大写，然后生成新的数组，如果按照常规做法需要利用快速枚举对数组每一个元素进行操作，并且还要分配一个空数组来存储处理过的元素。</p>

<p>而利用KVC的高阶消息传递，只需一句话就可以达到目的：</p>

<pre><code>NSArray *resultArr = [originArr valueForKey:@"capitalizedString"];
</code></pre>

<p>这样一步就实现了需求。</p>

<p>小结：</p>

<p>KVC是Objective－C特有的语法现象，可以加以利用实现代码的简洁性和可维护性。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ARC在IBOutlet属性中的使用]]></title>
    <link href="http://nijino.cn/blog/2013/06/24/iboutlet-arc/"/>
    <updated>2013-06-24T22:12:00+08:00</updated>
    <id>http://nijino.cn/blog/2013/06/24/iboutlet-arc</id>
    <content type="html"><![CDATA[<p>ARC提供四种所有权修饰符:
<li>strong<br/>
<li>weak<br/>
<li>unsafe_unretained<br/>
<li>autoreleasing</p>

<p>其中前三个可以用于属性中声明所有权。对于这三个用于属性声明的修饰符，下面分别讲讲他们对应的使用场景。</p>

<!-- more -->


<p>
1.strong<br/>
strong与之前的retain差不多，可以增加属性引用计数的值。在不需要的时候，需要手动设置属性为nil。</p>

<p>2.weak<br/>
weak是iOS5及以上才支持的修饰符。它被称为“归零弱引用”。可以只是持有指针而不增加引用计数来避免循环保留。当指针指向的内存被销毁后，声明weak的属性指针会自动置为nil，这也是它被称为归零弱引用的原因。</p>

<p>3.unsafe_unretained<br/>
对于iOS5以下版本，并不支持ARC中的weak声明，可以用unsafe_unretained声明来代替weak。unsafe_unretained同样也是不增加引用计数的值，但它没有“归零”的动作，需要手动操作，一般作为支持iOS5以下weak的替代方案。</p>

<p>解释了3种属性的意义，下面说说对于属性声明为IBOutlet时3种所有权修饰符的取舍以及使用技巧。<br/>
由于我自己很熟悉Interface Bulider中的操作，所以非常喜欢那种拉控件然后连线并直接声称属性代码的操作。对于直接从xib或者storyboard拉出来生成的IBOutlet属性，一般是选择strong还是weak呢？  <br/>
<strong>这里有个原则</strong>：如果该控件位于控件树的顶部，比如UIViewController下的view，那就应该选择strong，因为viewcontroller直接拥有该view。例如下图所示：</p>

<p><img src="http://nijino.cn/images/IBOutlet-ARC-1.png" alt="image" /></p>

<p>而如果控件是viewcontroller中view的子视图，对于这个子视图，它的所有者是它的父视图，代码中只是想引用一下这个子视图的指针而已，那么就应该选择weak（iOS5以下选择unsafe_unretained）。例如下图的UILabel:</p>

<p><img src="http://nijino.cn/images/IBOutlet-ARC-2.png" alt="image" /></p>

<p>对于以上的概念，我用一张图表来说明：</p>

<p><img src="http://nijino.cn/images/IBOutlet-ARC-3.png" alt="image" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[利用NSString的Hash方法比较字符串]]></title>
    <link href="http://nijino.cn/blog/2013/06/19/nsstring-hash/"/>
    <updated>2013-06-19T14:10:00+08:00</updated>
    <id>http://nijino.cn/blog/2013/06/19/nsstring-hash</id>
    <content type="html"><![CDATA[<p>实际编程总会涉及到比较两个字符串的内容，一般会用</p>

<p><code>[string1
isEqualsToString:string2]</code></p>

<p>来比较两个字符串是否一致。对于字符串的isEqualsToString方法，需要逐个比较字符串的内容，是比较耗时的操作。</p>

<p>偶然间我发现NSString类里有个hash方法，作用是返回NSString实例的散列值。众所周知，内容相同的字符串拥有相同的散列值，内容不同的字符串拥有不同的散列值。所以完全可以根据字符串散列值来判断两个字符串是否一致。</p>

<!-- more -->


<p>于是上面比较字符串的写法可以这么写（一般比较字符串是if语句的判断条件）：</p>

<p><code>if ([string1 hash] == [string2 hash]){  
}</code></p>

<p>实践中发现了一个问题：有时候字符串返回的散列值为负数，而苹果文档说hash方法一定返回无符号数，不知是不是位数问题造成的。</p>

<p><img src="http://nijino.cn/images/nsstring-hash.png" alt="image" /></p>

<p>例如：</p>

<pre><code>NSString *string1 = @"yyb";
NSString *string2 = @"nijino_saki";
NSLog(@"string1 hash %d",[string1 hash]);
NSLog(@"string2 hash %d",[string2 hash]);  
</code></pre>

<p>输出结果为：</p>

<p>  2013-06-19 18:47:11.612 test[26719:c07] string1 hash 530522127</p>

<p>2013-06-19 18:47:11.613 test[26719:c07] string2 hash -975949159</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[My First Blog on Octopress]]></title>
    <link href="http://nijino.cn/blog/2013/06/01/my-first-blog/"/>
    <updated>2013-06-01T06:00:00+08:00</updated>
    <id>http://nijino.cn/blog/2013/06/01/my-first-blog</id>
    <content type="html"><![CDATA[<h2>Hello Octopress!</h2>

<p>欢迎来到我的技术博客，这个博客是由Octopress构建的。
同时也欢迎访问我在<a href="http://blog.163.com/nijino_saki/">网易的博客</a>。</p>
]]></content>
  </entry>
  
</feed>
