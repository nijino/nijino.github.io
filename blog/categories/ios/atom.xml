<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | 杨叫兽的技术博客]]></title>
  <link href="http://nijino.cn/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://nijino.cn/"/>
  <updated>2013-12-23T23:52:17+08:00</updated>
  <id>http://nijino.cn/</id>
  <author>
    <name><![CDATA[杨叫兽]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS调用Emoji表情的方法]]></title>
    <link href="http://nijino.cn/blog/2013/10/05/emoji/"/>
    <updated>2013-10-05T22:11:00+08:00</updated>
    <id>http://nijino.cn/blog/2013/10/05/emoji</id>
    <content type="html"><![CDATA[<p>Emoji是iOS自带的表情符号，在短信和一些通讯软件中使用起来非常有意思。而如果在iOS软件中能使用这些表情符号，更会让软件显得生机勃勃，比如下面这个软件的评价视图：</p>

<p><img src="/images/Emoji-1.png" alt="image" /></p>

<!-- more -->


<p>
那么如何使用这些表情呢？主要的思路是拿到Emoji表情的编码。获得Emoji编码的方法是在Mac OS 10.7（lion）及以上版本中随便打开一个程序，选择编辑菜单中的最后一项：特殊字符。
在特殊字符窗口点击左上角下拉菜单，选择自定列表，在自定列表中如果表情符号没有勾选，请勾选。然后往下找到代码表，展开代码表并勾选Unicode选项，最后点击完成。</p>

<p><img src="/images/Emoji-2.png" alt="image" /></p>

<p>随便选择一个Emoji表情，右边的详细信息里就会显示这个表情的Unicode，我们需要的就是这个编码（不是括号中的）。</p>

<p><img src="/images/Emoji-3.png" alt="image" /></p>

<p>现在就可以使用这个表情了，将刚才查到表情的Unicode赋值给某个对象的text属性中。需要注意的是赋值时需要以"\U"开头，并写够8位，不够时用0在高位补齐。比如下面这个赋值写法：
<code>objc
self.label.text = @"\U0001F603";`    
</code>
在模拟器中的效果：</p>

<p><img src="/images/Emoji-4.png" alt="image" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在iOS应用中使用自定义字体]]></title>
    <link href="http://nijino.cn/blog/2013/09/05/using-custom-font/"/>
    <updated>2013-09-05T21:31:00+08:00</updated>
    <id>http://nijino.cn/blog/2013/09/05/using-custom-font</id>
    <content type="html"><![CDATA[<p>开发过iOS应用的朋友都知道，iOS平台里的字体样式很多，其中的大多数都很美观。但是在这些字体中并没有中文字体，如果想用一些好看的中文字体（比如楷体、隶书等）该怎么做呢？</p>

<p>其实iOS是支持自定义字体的。首先我们可以通过以下代码查看iOS都内置了哪些字体。  <br/>
``` objc 查询系统内置全部字体
NSArray <em>familyNames = [UIFont familyNames];
for (NSString </em>familyName in familyNames) {</p>

<pre><code>printf("Family: %s \n",[familyName UTF8String]);
NSArray *fontNames = [UIFont fontNamesForFamilyName:familyName];
for (NSString * fontName in fontNames) {
    printf("\tFont: %s \n",[fontName UTF8String]);
}
</code></pre>

<p>}
```</p>

<!-- more -->


<p> <br/>
从网上下载到自己想要的字体文件，比如：楷体_GB2312.ttf（.ttf和.odf均可）。将字体文件添加到项目中，并确保字体文件已加入工程的Copy Bundle Resources中：</p>

<p><img src="/images/using-custom-font-1.png" alt="image" /></p>

<p>同时要在工程的info.plist文件中添加一个名为"Fonts provided by application"的键，这个键的值是一个数组，将自定义字体文件的全名添加进去。</p>

<p><img src="/images/using-custom-font-2.png" alt="image" /></p>

<p>以上两步做完之后，还需要再执行一下之前提到的列举所有字体的代码，从打印的字体名称中找到自定义字体的名称。例如楷体_GB2312的字体名称为：KaiTi_GB2312。</p>

<p>现在就可以在项目中使用这个自定义字体了，例如将一个UILabel对象的字体设置为楷体_GB2312，代码如下：<br/>
<code>objc  
self.KaitiLabel.font = [UIFont fontWithName:@"STKaiti" size:25];  
</code><br/>
最后，送给大家一个使用了娃娃体Label的效果图：</p>

<p><img src="/images/using-custom-font-3.png" alt="image" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Settings.bundle的应用]]></title>
    <link href="http://nijino.cn/blog/2013/08/31/settings-bundle/"/>
    <updated>2013-08-31T16:08:00+08:00</updated>
    <id>http://nijino.cn/blog/2013/08/31/settings-bundle</id>
    <content type="html"><![CDATA[<p>Settings bundle是iOS开发中独有的一个特性，它可以存放app的一些设置，使用起来非常方便。最近公司有一个项目用到了这个技术，于是我认真的研究了一下，发现了一些需要注意的地方，想跟大家分享一下。</p>

<p>任何一个项目都可以设置它的settings bundle，settings bundle字面意思就是设置的大集合，里面可以存放系统的默认设置和用户选择的值。我们可以通过点击左下角的➕然后选择添加新文件（new file&hellip;）来生成：</p>

<p><img src="/images/settings-bundle-1.png" alt="image" /></p>

<!-- more -->


<p>
完成后会发现项目中多了一个Settings.bundle文件，展开后一般会有一个本地化的语言包（en.lproj）和Root.plist文件。本地化语言包是做国际化时用到的，而Root.plist就是用来控制这个app在系统设置中显示设置内容的文件。通过查看这个Root.plist文件你就会发现这个文件像一个大字典，并且它跟info.plist很接近，都是通过XML语法来实现的，你可以在“Preference Items”这个数组中添加一些设置项目，项目种类包括：Group、Multi Value、Slider、Text Field、Title和Toggle Switch。每一个项目都是一个字典，里面都包含有一些键值对。</p>

<p>如果是顺序添加的话直接选中“Preference Items”后点击它旁边的➕；如果不小心选错需要变更一下项目间的顺序怎么办呢？这里面有一个小技巧。因为Root.plist本质上是一个XML文件，所以我们可以通过查看它的源代码来调整顺序。在Root.plist文件单击右键，选择Open As→Source Code，将会显示XML格式的源码。把要更改顺序项目的<dict>和</dict>标签之间的内容（包括<dict>和</dict>标签）移到你想要的位置即可。</p>

<p><img src="/images/settings-bundle-2.png" alt="image" /></p>

<p>既然settings.bundle是app的设置总管，是不是程序一启动就会自动加载它里面的设置呢？我一开始也是这么认为的，可是在亲自尝试后发现不是那么回事。通过查阅相关文档我发现需要在程序启动成功后将settings.bundle中的设置注册到NSUserDefaults中去，这样才能取到设置的内容。</p>

<p>这里我推荐一个网站：<a href="https://developer.apple.com/library/ios/navigation/">iOS Developer Library</a>。这个网站是苹果官方的开发者库，里面有大量的官方文档、技术问答以及示例代码。尤其要提一下示例代码，苹果的示例代码是会更新的，有时候从Xcode中的Organizer查到的不一定都是最新的示例代码。</p>

<p>在苹果的Developer Library中我查到了最新的<a href="https://developer.apple.com/library/ios/samplecode/AppPrefs/Introduction/Intro.html#//apple_ref/doc/uid/DTS40007799">AppPrefs</a>示例代码，里面展示了如何在程序启动时拿到settings.bundle中的设置内容，以及如何立即更新更改的设置的方法（利用NSUserDefaultsDidChangeNotification）。我们可以直接把AppPrefs中的代码复制到自己的项目中使用。</p>

<p>最后说一下，一般示例代码中的内容就是为了展示思路和方法，最好不要照本宣科的完全复制。比如这个AppPrefs，它把读取settings.bundle内容的代码放在了AppDelegate中，我个人感觉这样做会让AppDelegte类显得十分臃肿，应该把读取的代码单独放在另外一个类中，我会选择做一个NSUserDefaults的类别（category）来存放。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[interface builder中的技巧]]></title>
    <link href="http://nijino.cn/blog/2013/08/28/interface-builder-skills/"/>
    <updated>2013-08-28T14:28:00+08:00</updated>
    <id>http://nijino.cn/blog/2013/08/28/interface-builder-skills</id>
    <content type="html"><![CDATA[<p>在我工作中经常会遇到有人吐槽Xcode中的interface builder（以下简称IB）不好用的开发者。在我看来，IB是一个非常棒的可视化开发工具，可以非常快捷的设置UI控件的大部分常用属性。下面就说两个IB中的技巧：</p>

<p>1.快速显示元素相对位置<br/>
这个技巧由<a href="http://weibo.com/ysy441088327">@余书懿</a>在新浪微博分享。<br/>
在IB中，选中一个control A,然后按住alt键，鼠标指向B，就显示A和B的相对位置关系，指向父view也行。</p>

<p><img src="/images/IB-skills-1.png" alt="image" /></p>

<!-- more -->


<p>
2.给页面添加水平、垂直辅助线<br/>
这个技巧是由我一个好朋友，同时也是陌陌的产品经理<a href="http://weibo.com/memtimen">@Memtimen</a>发现的。<br/>
IB中是可以添加水平和垂直的辅助线的。并且辅助线是可以拖动、重复添加和删除的。  <br/>
水平辅助线的快捷键是：Command ＋ Shift ＋ －<br/>
垂直辅助线的快捷键是：Command ＋ Shift ＋ ｜<br/>
当然，也可以通过菜单命令来生成，位置在Editor菜单下,如下图：</p>

<p><img src="/images/IB-skills-3.png" alt="image" /></p>

<p>辅助线的生成位置是由当前选定的view的中心点决定的，也就是说，如果当前选定了根view，那么将生成根view的辅助线；如果选中的是某一个UI控件，那就以这个控件的中心点生成。 （注意下图的UILabel &amp; UIButton）</p>

<p><img src="/images/IB-skills-2.png" alt="image" /></p>

<p>有了辅助线就可以轻松根据辅助线对齐控件（辅助线可以吸附），拖动辅助线可以查看辅助线把视图分割的两部分大小。</p>

<p><img src="/images/IB-skills-4.png" alt="image" /></p>

<p>至于删除辅助线嘛，就是把辅助线在其方向上移出视图边界，你会听到嗖地一声同时会看到一个丢纸团的动画，那就表明删除辅助线成功了。</p>

<p>小结：从我自身来讲，一开始做iOS开发也不是很爱用IB这个东西，感觉调整起来非常别扭。但是随着我做开发时间的变长，我越来越觉得IB非常好使，非常直观与节省时间。之前在《程序员》上看过一位计算机博士写的连载文章：<a href="http://www.douban.com/group/topic/23658084/">《Mac OS X 背后的故事》</a>，其中有一个章节是讲<a href="http://www.programmer.com.cn/9234/">Interface Builder</a>的，了解了IB的来龙去脉，才知道IB是乔帮主极力推崇的好东西。在我看来，IB才是Xcode这个IDE与众不同和精华所在，不会使用IB的iOS开发者不能算是真正iOS开发者，因为他从没有真正走进乔帮主的内心世界！</p>

<p>以上只是本人一家之言，各位看看了解一下就可以了，习惯这个东西不是那么容易改的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xcode5中cellForRowAtIndexPath:方法]]></title>
    <link href="http://nijino.cn/blog/2013/08/12/new-cell-for-row/"/>
    <updated>2013-08-12T14:57:00+08:00</updated>
    <id>http://nijino.cn/blog/2013/08/12/new-cell-for-row</id>
    <content type="html"><![CDATA[<p>UITableView是绝大部分iOS开发中必不可少的类。它的优势在于自身会维持一个可复用的队列，对于提高系统运行的流畅性有着不可磨灭的作用。</p>

<p>可复用的队列一般要写在UITableView的cellForRowAtIndexPath:方法中，之前的写法一般是这样：</p>

<p>``` objc
static NSString <em>CellIdentifier = @&ldquo;Cell&rdquo;;
UITableViewCell </em>cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier];</p>

<pre><code>if (cell == nil){
    cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:CellIdentifier];
}
</code></pre>

<p>// Configure the cell <br/>
return cell;  <br/>
```</p>

<!-- more -->


<p>上面这段代码的原理是首先会定义一个静态单元格标识，之后看看可复用队列中是否存在带有这个标识的单元格，如果没有就要重新生成。</p>

<p>对于一些拥有一段iOS开发经验的开发者来说这段代码应该是再熟悉不过，因为好多应用都会用到UITableView。但是最近我在Xcode DP版本上发现这段代码有了变化，在Xcode5中新生成UITableView的cellForRowAtIndexPath:方法中的写法变成了以下这样：
``` objc
static NSString <em>CellIdentifier = @&ldquo;Cell&rdquo;;
UITableViewCell </em>cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier forIndexPath:indexPath];</p>

<p>// Configure the cell&hellip;
return cell;
```  <br/>
表面上看UITableView好像支持了一个新方法：dequeueReusableCellWithIdentifier:forIndexPath:,这个方法是怎么回事呢？赶紧来看看这个方法的说明：
<img src="/images/xcode5-cellForRow.png" title="UITableView reference" ></p>

<p>从这个说明文档中可以知道这个方法也可以从复用队列中提取cell。如果cell没有在复用队列中，那就会调用cell的initWithStyle:reuseIdentifier:方法生成新的cell。至于之前在代码中指定cell的风格，现在已经可以在storyboard中指定了。</p>

<p>上面这个例子充分说明了苹果在简化代码方面作出的巨大努力。Objective-C本身语法就有些长，如果不深入研究一些简化代码的写法，那么一个项目的代码就会变的非常冗余。这也是程序员经常说的把代码写多容易，而把代码量减少并且不丧失功能才是有难度的。</p>

<p>另外我注意到这个方法是从iOS6.0版本开始支持的，可是在Xcode4.6.3中生成新的UITableViewController并不会默认生成新方法，只有Xcode5中才会生成，不知道这个方法在Xcode4.6.3中是否可以使用，需要通过实践来检验。</p>
]]></content>
  </entry>
  
</feed>
