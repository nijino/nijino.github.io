<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: NSArray | 杨叫兽的技术博客]]></title>
  <link href="http://nijino.cn/blog/categories/nsarray/atom.xml" rel="self"/>
  <link href="http://nijino.cn/"/>
  <updated>2014-04-22T23:06:59+08:00</updated>
  <id>http://nijino.cn/</id>
  <author>
    <name><![CDATA[杨叫兽]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Objective-C中3种枚举方法耗时比较]]></title>
    <link href="http://nijino.cn/blog/2014/03/11/comparison-for-3-enumeration-methods-in-objective-c/"/>
    <updated>2014-03-11T14:29:00+08:00</updated>
    <id>http://nijino.cn/blog/2014/03/11/comparison-for-3-enumeration-methods-in-objective-c</id>
    <content type="html"><![CDATA[<p>集合类对象（NSArray、NSDictionary、NSSet及其子类）在Objective－C中十分常见。经常会有遍历集合中所有对象的需求，Objective－C中遍历集合中对象的方法有三种：</p>

<p>1.C语言的for循环遍历;<br/>
2.Objective-C的快速枚举;<br/>
3.集合对象的枚举块语法。</p>

<p>为了测试以上三种枚举方法消耗的时间，我写了一个小程序，对含有1万个元素的数组进行打印操作，看看分别都消耗了多长时间。核心代码如下：</p>

<!-- more -->


<p>
``` objc 示例代码</p>

<pre><code>NSUInteger totalCount = 10000;
NSMutableArray *array = [NSMutableArray arrayWithCapacity:totalCount];
    //create an array including 10000 elements
for (int i = 0; i&lt;totalCount; i++) {
    array[i] = [@(i) stringValue];
}
    //C Language For Loop Enumeration
CFTimeInterval start1 = CACurrentMediaTime();
for (int j = 0; j&lt; totalCount; j++) {
    NSLog(@"%@",array[j]);
}
CFTimeInterval end1 = CACurrentMediaTime();
NSLog(@"C Language For Loop method %f",end1 - start1);
    //Objective-C Fast Enumeration
CFTimeInterval start2 = CACurrentMediaTime();
for (NSString *string in array) {
    NSLog(@"%@",string);
}
CFTimeInterval end2 = CACurrentMediaTime();
NSLog(@"Objective-C Fast Enumeration method %f",end2 - start2);
    //Objective-C Block Enumeration
CFTimeInterval start3 = CACurrentMediaTime();
[array enumerateObjectsWithOptions:NSEnumerationConcurrent usingBlock:^(NSString * obj, NSUInteger idx, BOOL *stop) {
    NSLog(@"%@",obj);
}];
CFTimeInterval end3 = CACurrentMediaTime();
NSLog(@"Objective-C Block Enumeration method %f",end3 - start3);  
</code></pre>

<p>```<br/>
其中CACurrentMediaTime()是一个返回系统时间的函数(<a href="https://developer.apple.com/library/mac/documentation/cocoa/Reference/CoreAnimation_functions/Reference/reference.html">苹果参考文档</a>)，可以通过结束时间减去开始时间计算代码所消耗的时间。(附：在Mac终端中输入w可以查询机器已经运行的时间信息，w属于Unix命令。)</p>

<p>部分运行结果：<br/>
2014-03-11 15:04:41.522 testspeed[19780:70b] C Language For Loop method 7.750710<br/>
2014-03-11 15:04:47.847 testspeed[19780:70b] Objective-C Fast Enumeration method 6.323673<br/>
2014-03-11 15:04:53.715 testspeed[19780:70b] Objective-C Block Enumeration method 5.866547</p>

<p>从以上结果可以看出，语法块的枚举耗时最短，快速枚举次之，for循环最慢。语法块枚举快的主要原因是枚举options中采用了NSEnumerationConcurrent，也就是并行处理，充分发挥了多核心的优势。当然这么做会导致输出顺序错乱，如果需求对顺序要求严格，就不能使用这个选项。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NSArray技巧两则]]></title>
    <link href="http://nijino.cn/blog/2014/01/05/nsarray-skills/"/>
    <updated>2014-01-05T12:21:00+08:00</updated>
    <id>http://nijino.cn/blog/2014/01/05/nsarray-skills</id>
    <content type="html"><![CDATA[<p>之前我在网易的技术博客中讲到去除NSArray中重复元素的方法(<a href="http://blog.163.com/nijino_saki/blog/static/800921442013421114117193/">地址</a>)。最近在看WWDC2013视频，发现苹果工程师对数组去重有更为简便的方法，还有一个对数组逆序的简便方法，赶紧记录下来备用。</p>

<!-- more -->


<p>
1.NSArray逆序
<code>objc NSArray逆序
NSArray *arr = @[@"first",@"second"];
arr = arr.reverseObjectEnumerator.allObjects;
NSLog(@"%@",arr);
</code>
输出结果为：
2014-01-05 13:52:09.303 CircleAudio[39584:70b] (
second,
first
)</p>

<p>2.NSArray快速去重
<code>objc NSArray快速去重
NSArray *arr = @[@"first",@"second",@"first"];
arr = [arr valueForKeyPath:@"@distinctUnionOfObjects.self"];
NSLog(@"%@",arr);
</code>
输出结果：
2014-01-05 13:54:53.457 CircleAudio[39976:70b] (
first,
second
)</p>

<p>以上的技巧都是从WWDC2013 session 228中学到的，其中还有一些技巧比如：联合两个数组并去重，感兴趣的同学可以自行下载视频研究。</p>

<p>[2014.4.21更新]对于更多有关KVC运算符的介绍，可以参考NSHipster的<a href="http://nshipster.cn/kvc-collection-operators/">博文</a>。</p>
]]></content>
  </entry>
  
</feed>
