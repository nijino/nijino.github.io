<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Objective-C | 杨叫兽的技术博客]]></title>
  <link href="http://nijino.cn/blog/categories/objective-c/atom.xml" rel="self"/>
  <link href="http://nijino.cn/"/>
  <updated>2014-03-11T15:51:07+08:00</updated>
  <id>http://nijino.cn/</id>
  <author>
    <name><![CDATA[杨叫兽]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Objective-C中3种枚举方法耗时比较]]></title>
    <link href="http://nijino.cn/blog/2014/03/11/comparison-for-3-enumeration-methods-in-objective-c/"/>
    <updated>2014-03-11T14:29:00+08:00</updated>
    <id>http://nijino.cn/blog/2014/03/11/comparison-for-3-enumeration-methods-in-objective-c</id>
    <content type="html"><![CDATA[<p>集合类对象（NSArray、NSDictionary、NSSet及其子类）在Objective－C中十分常见。经常会有遍历集合中所有对象的需求，Objective－C中遍历集合中对象的方法有三种：</p>

<p>1.C语言的for循环遍历;<br/>
2.Objective-C的快速枚举;<br/>
3.集合对象的枚举块语法。</p>

<p>为了测试以上三种枚举方法消耗的时间，我写了一个小程序，对含有1万个元素的数组进行打印操作，看看分别都消耗了多长时间。核心代码如下：</p>

<!-- more -->


<p>
``` objc 示例代码</p>

<pre><code>NSUInteger totalCount = 10000;
NSMutableArray *array = [NSMutableArray arrayWithCapacity:totalCount];
    //create an array including 10000 elements
for (int i = 0; i&lt;totalCount; i++) {
    array[i] = [@(i) stringValue];
}
    //C Language For Loop Enumeration
CFTimeInterval start1 = CACurrentMediaTime();
for (int j = 0; j&lt; totalCount; j++) {
    NSLog(@"%@",array[j]);
}
CFTimeInterval end1 = CACurrentMediaTime();
NSLog(@"C Language For Loop method %f",end1 - start1);
    //Objective-C Fast Enumeration
CFTimeInterval start2 = CACurrentMediaTime();
for (NSString *string in array) {
    NSLog(@"%@",string);
}
CFTimeInterval end2 = CACurrentMediaTime();
NSLog(@"Objective-C Fast Enumeration method %f",end2 - start2);
    //Objective-C Block Enumeration
CFTimeInterval start3 = CACurrentMediaTime();
[array enumerateObjectsWithOptions:NSEnumerationConcurrent usingBlock:^(NSString * obj, NSUInteger idx, BOOL *stop) {
    NSLog(@"%@",obj);
}];
CFTimeInterval end3 = CACurrentMediaTime();
NSLog(@"Objective-C Block Enumeration method %f",end3 - start3);  
</code></pre>

<p>```<br/>
其中CACurrentMediaTime()是一个返回系统时间的函数(<a href="https://developer.apple.com/library/mac/documentation/cocoa/Reference/CoreAnimation_functions/Reference/reference.html">苹果参考文档</a>)，可以通过结束时间减去开始时间计算代码所消耗的时间。(附：在Mac终端中输入w可以查询机器已经运行的时间信息，w属于Unix命令。)</p>

<p>部分运行结果：<br/>
2014-03-11 15:04:41.522 testspeed[19780:70b] C Language For Loop method 7.750710<br/>
2014-03-11 15:04:47.847 testspeed[19780:70b] Objective-C Fast Enumeration method 6.323673<br/>
2014-03-11 15:04:53.715 testspeed[19780:70b] Objective-C Block Enumeration method 5.866547</p>

<p>从以上结果可以看出，语法块的枚举耗时最短，快速枚举次之，for循环最慢。语法块枚举快的主要原因是枚举options中采用了NSEnumerationConcurrent，也就是并行处理，充分发挥了多核心的优势。当然这么做会导致输出顺序错乱，如果需求对顺序要求严格，就不能使用这个选项。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[给NSLog增加输出功能]]></title>
    <link href="http://nijino.cn/blog/2014/03/02/add-new-function-to-nslog/"/>
    <updated>2014-03-02T21:34:00+08:00</updated>
    <id>http://nijino.cn/blog/2014/03/02/add-new-function-to-nslog</id>
    <content type="html"><![CDATA[<p>之前在<a href="http://blog.163.com/nijino_saki/blog/static/8009214420134128146215/">老博客</a>里讲到编写一个DLog宏替代NSLog输出更多的打印信息。如果之前工程里NSLog很多就需要把所有的NSLog替换成DLog。这么做是不是感觉有点麻烦？其实还有更简单的办法，就是直接写一个NSLog的宏，替换掉Xcode中已存在的宏，同样可以打印需要的信息。只需将下列代码放入prefix.pch文件中：</p>

<p>``` objc</p>

<h1>define NSLog(format, &hellip;) do {\</h1>

<p>fprintf(stderr, &ldquo;&lt;%s : %d> %s\n&rdquo;,\</p>

<pre><code>    [[[NSString stringWithUTF8String:__FILE__] lastPathComponent] UTF8String],\
    __LINE__, __func__);\
</code></pre>

<p>(NSLog)((format), ##<strong>VA_ARGS</strong>);\
fprintf(stderr, &ldquo;&mdash;&mdash;&mdash;&ndash;\n&rdquo;);\
} while (0)
```</p>

<p>如果还想深入了解宏定义的知识，请参考<a href="http://www.cocoachina.com/applenews/devnews/2014/0122/7738.html">这里</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[KVC技巧二则]]></title>
    <link href="http://nijino.cn/blog/2013/07/02/using-kvc/"/>
    <updated>2013-07-02T14:31:00+08:00</updated>
    <id>http://nijino.cn/blog/2013/07/02/using-kvc</id>
    <content type="html"><![CDATA[<p>说两个与KVC相关的技巧。</p>

<p>1.KVC与字典</p>

<p>有时候我们需要取出嵌套字典中的某个键的值。例如某个嵌套字典：</p>

<p><code>objc
NSDictionary *dict = @{@"subDict":@{@"subKey":@"aStr"}};
</code></p>

<p>需要取出<code>subKey</code>这个键的值。以前总是用<code>valueForKey</code>嵌套的语法来做，其实根本不用那么麻烦，直接利用<code>valueForKeyPath</code>方法就可以实现。代码如下：</p>

<p><code>objc
NSString *str = [dict valueForKeyPath:@"subDict.subKey"];
</code></p>

<!-- more -->


<p>2.KVC实现高阶消息传递</p>

<p>有时候需要对数组中每个对象调用某一个方法后生成新的数组，我们可以利用KVC的高阶消息传递功能来实现。例如有下面这样一个数组：</p>

<p><code>objc    
NSArray *originArr = @[@"octopress",@"nijino",@"saki"];
</code></p>

<p>我想将这个数组中的每一个元素首字母大写，然后生成新的数组，如果按照常规做法需要利用快速枚举对数组每一个元素进行操作，并且还要分配一个空数组来存储处理过的元素。</p>

<p>而利用KVC的高阶消息传递，只需一句话就可以达到目的：</p>

<p><code>objc  
NSArray *resultArr = [originArr valueForKey:@"capitalizedString"];
</code></p>

<p>这样一步就实现了需求。</p>

<p>小结：</p>

<p>KVC是Objective－C特有的语法现象，可以加以利用实现代码的简洁性和可维护性。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[利用NSString的Hash方法比较字符串]]></title>
    <link href="http://nijino.cn/blog/2013/06/19/nsstring-hash/"/>
    <updated>2013-06-19T14:10:00+08:00</updated>
    <id>http://nijino.cn/blog/2013/06/19/nsstring-hash</id>
    <content type="html"><![CDATA[<p>实际编程总会涉及到比较两个字符串的内容，一般会用</p>

<p><code>objc
[string1 isEqualsToString:string2]
</code></p>

<p>来比较两个字符串是否一致。对于字符串的isEqualsToString方法，需要逐个比较字符串的内容，是比较耗时的操作。</p>

<p>偶然间我发现NSString类里有个hash方法，作用是返回NSString实例的散列值。众所周知，内容相同的字符串拥有相同的散列值，内容不同的字符串拥有不同的散列值。所以完全可以根据字符串散列值来判断两个字符串是否一致。</p>

<p>于是上面比较字符串的写法可以这么写（一般比较字符串是if语句的判断条件）：</p>

<p><code>objc
if ([string1 hash] == [string2 hash])
</code></p>

<!-- more -->


<p>实践中发现了一个问题：有时候字符串返回的散列值为负数，而苹果文档说hash方法一定返回无符号数，不知是不是位数问题造成的。</p>

<p><img src="/images/nsstring-hash.png" title="NSString hash method reference" ></p>

<p>例如：  <br/>
<code>objc 示例代码
NSString *string1 = @"yyb";
NSString *string2 = @"nijino_saki";
NSLog(@"string1 hash %d",[string1 hash]);
NSLog(@"string2 hash %d",[string2 hash]);  
</code>
输出结果为：</p>

<p>  2013-06-19 18:47:11.612 test[26719:c07] string1 hash 530522127<br/>
2013-06-19 18:47:11.613 test[26719:c07] string2 hash -975949159</p>
]]></content>
  </entry>
  
</feed>
